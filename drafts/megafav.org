#+title: bex, ANF, and my two #megafavnumbers

* Intro
** my #megafavnumbers
So #megafavnumbers is a youtube playlist where a bunch
of math-related youtube channels are sharing their
favorite numbers greater than 1 million.

I'm more of a programmer than a mathematician.
I'm not sure I really have a favorite number, but
but there are two numbers I think about quite a bit.

: X =             4,294,967,296
: K =   614,889,782,588,491,410

The first one might be pretty familiar to other programmers
watching this - it's just 2^32.

The second is the product of the first 15 prime numbers.
Apparently, that's called a [[https://en.wikipedia.org/wiki/Primorial][primorial]].

As far as I know, these numbers are only mildly interesting
mathematically, but they both play a big role in one of my main
programming projects, which is a rust crate that I call bex.

** bex
# show crates.rs / github page

Bex is short for "boolean expression", and not surprisingly, it
provides some data structures for working with large boolean
expressions.

https://crates.io/crates/bex
https://github.com/tangentstorm/bex
https://docs.rs/bex/0.1.4/bex/

This video is a little bit about bex, a lot about boolean
expressions, and eventually how and why those two numbers
make a difference.



* What is a Bdd?
** show the wikipedia page and my own diagram(s) in vue
here we have a truth table
and here we have a fully expanded decision tree
but notice that these nodes at the bottom branch to the same place on both sides
so we can replace them with the leaf node
but also we don't need so many copies of this node.
generalize a tree with a dag
keep doing that and we have a fully reduced bdd

nice feature is that the representation is cannonical
also there are algorithms that let you combine functions together efficiently.

** jsfiddle demo
# show jsfiddle
i made a little demo in coffeescript where you can experiment with the truth table

** bdd as simple programming problem
# show bddlab on github

https://github.com/tangentstorm/bdd-labs/

- knuth wrote a whole book about them
- used in hardware layout, sat solvers
- pretty easy to implement


** the idea of a bdd base

- more advanced things, like combining expressions, or applying one to another.
- share nodes even across functions
- two kinds of cache:
  - simple vhl cache
  - this node AND this node, or more generally, an ITE triple

* Early bex
** learning project

Sometimes I make tetris.
https://github.com/learnprogramming/learntris

often I make a BDD:
https://github.com/tangentstorm/bdd-labs/

I've made implementations in elixir, j, python, pascal
So when I decided to learn rust, I made bex.

** why rust?
- had experimented with concurrency in elixir, but very slow
- pascal i was working on the idea of a solver
- pascal is one of my favorite languages, but i didn't really trust my ability to make things threadsafe.
- rust promised to make concurrency safe
- hoped to combine low level optimizition with concurrency


** TODO pascal is missing some pieces in git
** timeline
*** 2015 elixir, python
*** 2017 pascal solver
*** 2018 feb: started learning rust
*** 2018 dec: open source as bex 0.1.0
*** 2019 shell, multi-threaded workers
*** 2020 ANF, unified NID, VidOrdering, Registers/Cursors
** early bex

Working on the train.

Really like rust.

https://news.ycombinator.com/item?id=14756529

These are tools to keep your pointers safe.

** optimizations nudged by rust

But eventually threw all that away, and now I use
this idea called a NID.

Some operations can be done directly on a NID.

For example, the NID knows the topmost variable,
and it tells you.

The most expensive operation is =ITE::norm=, and it
can be performed entirely on the CPU on three
64-bit NIDs.

Early on, bex was an exercise in optimization.

** multi-core support

non-linear speedup.
out-of-order, short circuiting

even on a 2-core machine, steps that once took 20 seconds dropped to 0 seconds.

around this time, decided it wasn't just a toy but might actually become a useful application.


* Towards a standard benchmark
** standard test problem

- never done any benchmarks
- so i need a benchmark

So that's where this number comes in:

: */p:i.15

(This is a language called J. It's a full programming language,
but it's also a mathematical notation, and probably one of the
best desktop calculators you can get.)

:   (2^64) > */p:i.15
: 1
:   (2^64) > */p:i.16
: 0

** the problem to solve

which pairs of 32-bit numbers that multiply to this function

Here's the line from bex:

: */L:0 (0,"1#:i.2^n-1) </."1 |.p:i.n=:15

right side is same as before, except n=: assigns a name to the 15.

this part is a table:

: (0,"1#:i.2^n-1)



: viewmat (0,"1#:i.2^n-10) [ p:i.n=:15

: (0,"1#:i.2^n-1) </."1 |.p:i.n=:15

so the idea is we're partitioning these into a left and right argument.

then take the product at level 0

: */L:0

I'm not going to break the other lines down, but
basically

:   xys =: ({~[:I.([:*./(2^32)>])"1) \:~\:~@;"1 xy0

the right part says get rid of the boxes, sort the individual lines, then sort the whole table
and on the left it says only include the lines where both numbers are less than 2^32.

(And yes, 2^32 is my other favorite number, but it's just showing up by coincidence here.)

:   txt =: ,('    ',LF,~}:)"1 ] _4 ;\ ([: < ','10}  3|.'), (', ": )"1 xys
:   txt 1!:2 <'nums.txt'

then these two lines format the numbers into columns with parens and and commas
and dump it to a text file, which I then just copied and pasted into this rust file.

** TODO the full problem statement

So now, here's the actual benchmark:

#+begin_src rust
find_factors!(BDD, X32, X64, K as usize, factors(), false); }
#+end_src

It's a macro that says use a BDD to find all pairs of 32-bit
factors of K as a 64-bit number, arranged so that the first
number is less than the second, and then check the answers
against this list. (The last parameter says whether or not
to show some extra debug information. It really ought to be
a command line parameter, but whatever.)

So let's see what happens when we run this.

: cargo run --bin bdd-solve


Off to a good start.

This would be a good time for my scroll lock key to actually work,
but since it doesn't I can just scroll up a little to freeze the
display.

And there's a bunch of stuff about ands and xors, but it also says
step xxx of 7997 so we're already at xxx percent.

Unfortunately, that number is fairly misleading. The way the
current solver works, it knows how many steps it will take to
construct the solution, but it doesn't know how long each step
is going to take.

You can see already it's slowing down.

So what is it trying to do?

If it works, then the output will be a BDD on 64 input bits,
and 1 output bit, and it'll represent the function that returns
true when the first 32 bits multiplied by the second 32 bits
is this number K.

Since it has 64 input bits, that means the truth table is
2^64 bits wide, which is an INSANELY large number.

This is that story about the grains of rice on the chessboard.
As payment for inventing the game of chess, you ask the emperor
for a grain of rice on the first square, two in the second square,
double each time, and after a while, the emperor's accountants
figure out what's going on and chop your head off.

So yeah, the truth table is 2^64 entries wide. Each entry
represents a pair of 32-bit numbers that might or might
not multiply, but we happen to know that there are only
3,827 such numbers.

A BDD ought to be able to represent this truth table fairly
efficiently. The problem is just constructing it from the
problem statement.

** give up

# I actually stopped this around 5% because my computer locked up.
# It was right after I got up to go to the bathroom so I suspect
# the thread just got moved to the foreground and didn't want to
# give back control. Either way, I should probably manually stop
# the program.

I wanted a problem with an easy answer to generate and check
but that would be hard for bex.

I knew multiplication is particularly hard for bdds - meaning you
wind up with a very large bdd.

But I didn't know how hard it would be.

Turns out it's really really hard.
The percentage numbers are somewhat misleading.
It's going to get slower and slower as it goes along.

I've never actually seen this program finish,
and it's not garbage collecting, so I think last time
i tried, it just churned for a few days, and then finally
crashed when it ran out of RAM.

So yeah, it turned out my initial problem is way too
hard for bex to solve right now, and so the reason
that number is always on my mind is simply that it
represents a pretty ambitious goal to shoot for.


* The solver
** TODO talk about xints
** what's the point?

But you might ask, what's the point of this?

First of all, I already know the answer to the problem,
because that's what I started with.

Second of all, who cares?

The point isn't really to solve this particular problem.
The point is to solve whatever problem you throw at it
as quickly as possible.

The solution algorithm I'm using is pretty simplistic.

** So what can we do?

Well one nice thing about the factoring problem is that
it scales way down.

A few versions of the problem actually run in a few seconds
on my machine.

: cargo test

Some of these are just general unit tests.

By the way, if you add one character to the j program then instead of
the final product, you'll see the running product, which is the first
15 primorials.

: */\p:i.15
: ,.*/\p:i.15

So currently, bex can solve the first four of these fast enough to
run as unit tests.

: cargo test --lib nano_bdd

#+begin_src rust
#[test] pub fn test_nano_bdd() {
  use {bdd::BDDBase, int::{X2,X4}};
  find_factors!(BDDBase, X2, X4, 6, vec![(2,3)], false); }
#+end_src

let's run again with that false changed to true.

** TODO describe the diagrams that show up
eq.svg is the multiplication
lt.svg is the condition that x<y
ast.svg is the combination of those two
x-final.svg is the final AST

*** TODO show node numbers in the AST (before and after renumbering)
*** TODO render and show each step as a (stop-motion) "animation"

** TODO generate diagrams with the original and reverse orders
use custom shapes https://www.graphviz.org/doc/info/shapes.html
now that #1 is at the bottom...


* slowtests and import/export

210 is an 8-bit number, and the tests look for two four-bit factors.
If I ask it to search for two 8-bit numbers that multiply to 210 as
a 16-bit number, then it winds up taking 11 minutes. Of course I don't
actually need all 16 bits in the answer, so it might be interesting
to have it discard the 16 bits in the AST stage.

(Which means it ought to also take 11 minutes for solving 30030)

But also, the way this works, it generates the entire BDD for
the multiplication of two input numbers from scratch in a fresh BDD
base every single time, even though this is completely generic.
There's no reason this function couldn't be cached to disk and
loaded into the base on demand.

Then it would just be a matter of pulling that pre-compiled function
in from a stored library.

Bex doesn't yet have an import feature at runtime, but you can save
and entire bases. Import and export should only be a few lines of code.
It's not hard at all, just something I haven't gotten around to.

** TODO make and show a ticket for import/export

also there could be one stored multiplication database, 2*n output
bits for 2*n input bits, and you could just look at the ones you wanted.

import/export is easy, but i'd also have to teach the solver when to
use the imported function, which means having AST nodes aware of n-bit
ints... Which means making the AST representation much more expressive
in general.

(this is something i'm thinking about)


* algebraic normal form.

meanwhile, i had another idea

bdd says you can represent any boolean function with if/then/else.
obvious just by looking at how the binary tree maps to the truth table.

assertion:

  1. you can represent any boolean function with (and, xor, 1)
  2. and in particular, we can make a bdd-like structure
     that uses a different ternary function:

: bdd: V ? H : L         NB. if V then H else L  ("var", "hi", "lo")
: anf: V * H + L         NB. + is "plus mod 2"
: anf: L ~: V *. H       NB. j syntax

nand is sufficient to generate all 16 boolean functions.
fun to work out for yourself. here's a proof in J:

https://github.com/tangentstorm/tangentlabs/blob/master/j/nornand.ijs


p =: 0 0 1 1
q =: 0 1 0 1

p na q

proof: nand = (1 & xor)@AND

(show the 16 2-bit truth tables?)


functionally complete operator sets
NAND = AND, XOR, T
https://en.wikipedia.org/wiki/Functional_completeness


: (1+a)+(b+c)+(a+b)                // 6 terms (4 unique)
:  1+a + b+c + a+b                 // simply remove the parens
:  1   + c                         // cancel a, b

: (1+a)(b+c)(a+b)                  // 6 terms (4 unique)
: (1+a)(b(a+b)+c(a+b))
: (1+a)(b(a+b)+ca+cb))
: (1+a)(ba+bb+ca+cb)
: (1+a)(ba+b+ca+cb)
: (ba+b+ca+cb)+a(ba+b+ca+cb)
: (ba+b+ca+cb)+ba+ba+ca+cba
: ba+b+ca+cb+ba+ba+ca+cba
: ab+b+ac+bc+ab+ab+ac+abc
: ab+ab+ab+abc+ac+ac+b+bc          // cancel
:       ab+abc      +b+bc          // 4 terms (4 unique)
: a(b+bc)+(b+bc)                                              b(a+ac+1+c)      // not allowed
: a(b(1+c)) + (b(1+c))                                        b(1+a+ac+c)
: a(b(1+c)) + b(1+c)                                          b(1+a(1+c)+c)


: (a+b+c)(d+e+f)                     / 3+3 = 6 terms
: ad+ae+af+bd+be+bf+cd+ce+cf         / 3x3 = 9 terms
: a(d+e+f) + b((d+e+f) + c(d+e+f))   / 6 terms (not counting 0)


* visual ANF : numbers at the bottom

truth table <-> anf
we can think of that number as representing a set of 32 items.
langlet, power set
power set.

:  |:#:i.2^5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1
0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1
0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1

:  viewmat |.&.|:~:/\^:(<32)32#1

you can see that the first term in anf tells you what the first
entry in the truth table is.

when you consider these bitmaps to be ongoing, infinite patterns, then
it doesn't really make sense that their names should constantly change
depending on how many variables you have.

this is what convinced me to renumber these with the names at the bottom.

but now, with these at the bottom, something interesting happens.

** xor fiddle

xor: https://jsfiddle.net/tangentstorm/vkmLq2bj/latest/


* new idea: truth tables in the NID
- So let's go back to that number 2^32
- 32 bits can store an entire function of 5 variables
- either as truth table or ANF polynomial (factor set)


* TODO make the change to const NIDs (on a new branch)

I always like to show how to actually make a change, and this seems like a good one.

** TODO collect some more metrics
- number of steps
- count each kind of hash lookup, and whether it was found
- count calls to ITE::norm (can do this in dispatcher as it sends/receives the answers)
- or just analyze the wip table when the solution comes in to see what's still wip?

** TODO =NID::is_tbl=
- add a new bit for tables (or just use existing T) ?
- redefine =is_const= to specifically check equality for I/O

** TODO implement directly in AST for now.
- completely eliminate the work from nano test

** TODO render const nodes with braille
Mostly because it can hold a 5-variable truth table or a
5-variable anf expression. braille font
binary decision diagrams
bdd: https://jsfiddle.net/tangentstorm/bLbayo6c/

** TODO implement whenhi / whenlo
this should let it get down to I,O and work for BDD automatically.

** TODO how to handle for ANF?
- simple const-const is easy
- how to do const + true ANF?
- i think implementing =when_hi= and =when_lo= /might/ be sufficent.

* TODO test the change!
- compare the steps taken for each node
- how to handle for AST?

* TODO back to our number

want it to run faster than brute force
but still maintain the benefits of caching

next higher numbers: truth table size doubles with each new input bit

but that means the number of possible truth tables squares
wouldn't actually be hard to store a truth table that big.
2^32 bits = 500 MB uncompressed. (why? well 2^32 pointer gives you 4 gb,
but that's bytes, and we need bits, so divide by 8. 4g / 8 = 0.5g, or 500mb)
That's a pretty huge file, but it's not *that* huge.
Maybe it's possible to have multiple worker threads generate the input truth
table in linear ram from a BDD, and a stream processing thread to combine them.
BDD itself is a compression algorithm, but maybe other compression algorithms
could be used to unpack truth tables.


* TODO bex/bdd community?
link in the description to a forum
Remains an exercise in optimization.

https://www.reddit.com/r/bex_rs/new/

* TODO future directions(?)
# probably move this to a document on bex
- refactor and reuse BDDSWarm components for ANF, future VHL bases
- generalize the wip/distributed solver
- extend the raw truth table idea to arbitrary registers
  - process with streaming instructions or the gpu
  - convert to/from BDD for compression
- mixed representation for wip
  (meaning registers at the bottom, bdd up top)
- lazy solving of regions
  (solve truth table left to right to reach first answer faster)
- combine bottom-up and top-down solving
- dynamic sifting (variable permutations)
- new base formats
  - zdd
  - bic
  - cnf ? sat solver
  - aig ? https://en.wikipedia.org/wiki/And-inverter_graph
- gpu and fpga workers
- var sets for functions of n vars, no matter which n they are
  there might be 500 input variables, but only using 15.
- better AST
  - track topmost variable in NID even for AST
  - allow any number of arguments
  - full combinatory logic
  - operations on xints (nid arrays)
- import/export stored functions
- apply functions across base types


* ------------------------------------------

* TODO more example(s) from old repo?
* TODO novel parts about bex

- algebraic normal form
- shell

* tangents
** 2^32-1

x-1 = largest 32-bit unsigned integer
      "negative zero" in ones compliment

four bytes:
  more colors than on your computer screen
  brightest color on screen
  maximum number of ip addresses
  four gb of ram

** too small

little more than half the population of earth
  https://en.wikipedia.org/wiki/World_population

414 people on earth have more money than that.
   https://www.forbes.com/billionaires/
$196.29 billion USD bezos
  21.43 trillion USD (2019)

zimbabwe:
  https://en.wikipedia.org/wiki/Hyperinflation#Ten_most_severe_hyperinflations_in_world_history
  https://en.wikipedia.org/wiki/Zimbabwean_dollar


* --- thoughts from train
- sha256 as motivator? solving tools in general aren't up for the challenge
- move the future directions to a separate file
- how you can get involved
- nid was gently encouraged by rust (working with the grain of the language)
  - might say not memory safe, but it can be saved and copied

- anf: in addition, the anf base attempts to do the and and xor operations on the data in this form
- the idea is that when you're manipulating formulas, there's likely to be a lot of reuse from
  operations distributing over each other, and often, that can be captured near the top
  of the graph, without necessarily merging every leaf.


- when you're just talking about formulas, the variable order doesn't matter.
- i called this pattern a, but in a traditional bdd, you number from the top down
- but if you think about these as infinite patterns that appear in almost every expression,
- it makes sense for them to always have the same name"

- early on; emphasise canonical representations. bdd and anf are both cannonical. ast is not.

- explain the "combining functions efficiently" paradox: compression reduces a lot of steps because you can work at the top of the dag.
- one operation at the top might match 2^n operations at the bottom.
- but there is also overhead of fetching nodes from memory
- so it makes sense to balance the two
- I think how big the "registers" are might have to do with how much entropy you expect your function to have.
- the more regularity and structure, the more working near the top will save work
- the more random your data, the better it is to stream
- so it might make sense to let users configure this on each run.
